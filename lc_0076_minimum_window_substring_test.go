package main

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

// https://leetcode.com/problems/minimum-window-substring
func Test_lc_0076_minimum_window_substring(t *testing.T) {
	cases := []struct {
		s, t, result string
	}{
		{"abookoobaabeeeb", "bb", "baab"},
		{"aaa", "aaa", "aaa"},
		{"aaa", "a", "a"},
		{"ADOBECODEBANC", "ABC", "BANC"},
		{"sgdsghg", "a", ""},
	}
	for _, c := range cases {
		assert.Equal(t, c.result, lc_0076_minimum_window_substring(c.s, c.t))
	}
}

// Две метки, скользящее окно.
// Двигаем правую метку и набираем такую подстроку, чтобы она соответствовала паттерну, т.е. получила состояние.
// Далее двигаем левую метку, пока не потеряем это состояние. На каждой итерации сохраняем длину подстроки, если она имеет состояние.
// Как только потеряли состояние, двигаем правую метку до следующего подходящего символа,
// т.е. убираем "мусор": те элементы справа, которые не должны входить в подстроку с состоянием.
// Делаем так до тех пор, пока собрать состояние уже не получается. Возвращаем наименьшую длину подстроки.
func lc_0076_minimum_window_substring(s, t string) string {
	state, curr, ir, jr, have := map[byte]int{}, map[byte]int{}, 0, len(s)+1, 0
	for i := range t {
		state[t[i]]++ // Заполняем образцовое состояние.
	}
	for i, j := 0, 0; i != len(s); {
		for j != len(s) { // Набираем состояние.
			if need, ok := state[s[j]]; ok {
				curr[s[j]]++            // Прибавляем счётчик элемента, так как он нам встретился.
				if curr[s[j]] == need { // Если набрали необходимое количество для элемента, то инкрементируем счётчик.
					have++
				}
			}
			j++                     // Двигаем правую метку.
			if have == len(state) { // Если счётчик равен длине образца, то количество набранных символов не меньше, чем в образце.
				break
			}
		}
		if have != len(state) { // Если не набрали состояние, то выходим, так как далее будет только удаление элементов, и набрать его будет уже невозможно.
			break
		}
		for have == len(state) { // Удаляем элементы, пока не потеряем состояние.
			if j-i < jr-ir {
				ir, jr = i, j // Запоминаем длину текущей подстроки с состоянием при необходимости.
			}
			if need, ok := state[s[i]]; ok {
				if curr[s[i]] == need { // Если элемент потерял состояние, то есть стал меньше образца, то декрементируем счётчик.
					have--
				}
				curr[s[i]]-- // Убавляем счётчик элемента, так как мы его исключили из подстроки.
			}
			i++ // Двигаем левую метку.
		}
		for i != j { // Удаляем мусор слева из подстроки.
			if _, ok := state[s[i]]; !ok {
				i++ // Двигаем левую метку.
			} else {
				break
			}
		}
	}
	if jr == len(s)+1 { // Так и не собрали состояние.
		return ""
	}
	return s[ir:jr]
}
