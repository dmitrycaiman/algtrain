package main

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

// https://leetcode.com/problems/maximum-subarray
func Test_lc_0053_maximum_subarray(t *testing.T) {
	cases := []struct {
		input  []int
		result int
	}{
		{[]int{-2, 1, -3, 4, -1, 2, 1, -5, 4}, 6},
		{[]int{5, 4, -1, 7, 8}, 23},
		{[]int{1, 2, -1, -2, 2, 1, -2, 1, 4, -5, 4}, 6},
		{[]int{-1, -2}, -1},
		{[]int{31, -41, 59, 26, -53, 58, 97, -93, -23, 84}, 187},
		{[]int{3, -2, -3, -3, 1, 3, 0}, 4},
		{[]int{2, -2, -2, 0, -2, 2, 2}, 4},
		{[]int{3, 1, -3, -3, 2, -1}, 4},
	}
	for _, c := range cases {
		assert.Equal(t, c.result, lc_0053_maximum_subarray(c.input))
	}
}

// Представим себе массив из одного элемента. Тогда его наибольшей суммой будет сам этот элемент. Теперь добавим к массиву ещё один
// элемент: тогда наибольшей суммой будет либо сумма с первым элементом, либо отдельно стоящий второй элемент. Таким же образом рассуждаем
// при добавлении третьего элемента: наибольшая сумма будет состоять либо из наибольшей суммы от массива из двух элементов, либо только
// из третьего элемента. Из этого можно составить формулу: sum[i] = max(sum[i-1] + nums[i], nums[i]). То есть на каждом шаге мы решаем,
// продолжаем ли мы "набирать" сумму предыдущего подмассива или начинаем новый. Таким образом на каждой итерации по массиву мы имеем
// наибольшее значение суммы для массива, заканчивающегося в элементе i.
func lc_0053_maximum_subarray(nums []int) int {
	result := -10_001
	best := result
	for _, v := range nums {
		result = max(result+v, v)
		best = max(best, result)
	}
	return best
}
